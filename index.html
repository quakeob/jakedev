<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jake davis</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .main-content {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            background: #0a0a0a;
            border-right: 1px solid #1a1a1a;
        }

        .graph-container {
            width: 50%;
            position: relative;
            background: #000000;
        }

        #canvas {
            display: block;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .graph-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 16px;
            border: 1px solid #333;
            font-size: 10px;
            color: #666;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 8px 12px;
            border: 1px solid #ffffff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            font-size: 12px;
            z-index: 1000;
            color: #ffffff;
            letter-spacing: 0.5px;
        }

        .tooltip.visible {
            opacity: 1;
        }

        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }

            .graph-container {
                width: 100%;
                height: 40vh;
                border-right: none;
                border-top: 1px solid #1a1a1a;
            }

            .main-content {
                height: 60vh;
            }
        }

        .path {
            margin-bottom: 8px;
            cursor: pointer;
            padding: 8px 0;
            transition: all 0.15s ease;
            color: #666;
        }

        .path:hover {
            color: #fff;
        }

        .content {
            display: none;
            margin-top: 20px;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .content.active {
            display: block;
        }

        .back {
            cursor: pointer;
            margin-bottom: 20px;
            padding: 6px 12px;
            display: inline-block;
            color: #666;
            border: 1px solid #333;
            transition: all 0.15s ease;
            font-size: 13px;
        }

        .back:hover {
            border-color: #fff;
            color: #fff;
        }

        .file {
            margin: 4px 0;
            cursor: pointer;
            padding: 6px 0;
            transition: all 0.15s ease;
            color: #666;
        }

        .file:hover {
            color: #fff;
        }

        pre {
            white-space: pre-wrap;
            margin: 15px 0;
            color: #ccc;
            background: #0f0f0f;
            padding: 16px;
            border: 1px solid #1a1a1a;
            font-size: 13px;
            line-height: 1.6;
        }

        a {
            color: #fff;
            text-decoration: none;
            border-bottom: 1px solid #333;
            transition: all 0.15s ease;
        }

        a:hover {
            border-bottom-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div id="main">
                <div class="path" onclick="navigate('home')">/home/jake</div>
                <div class="path" onclick="navigate('projects')">/home/jake/projects</div>
                <div class="path" onclick="navigate('about')">/home/jake/about.txt</div>
                <div class="path" onclick="navigate('contact')">/home/jake/contact</div>
                <div class="path" onclick="navigate('resume')">/home/jake/resume.pdf</div>
                <div class="path" onclick="navigate('misc')">/var/log/thoughts</div>
                <div class="path" onclick="navigate('hidden')">/test/1099/w-2/fun/find-me.txt</div>
            </div>

            <!-- Home Directory -->
            <div id="home" class="content">
                <div class="back" onclick="goBack()">← /</div>
                <div class="file" onclick="navigate('about')">about.txt</div>
                <div class="file" onclick="navigate('contact')">contact/</div>
                <div class="file" onclick="navigate('projects')">projects/</div>
                <div class="file" onclick="navigate('resume')">resume.pdf</div>
                <div class="file">.bashrc</div>
                <div class="file">.ssh/</div>
                <div class="file">documents/</div>
            </div>

            <!-- Projects -->
            <div id="projects" class="content">
                <div class="back" onclick="goBack()">← /home/jake</div>
                <div class="file">neural-networks/</div>
                <div class="file">web-scraper/</div>
                <div class="file">crypto-bot/</div>
                <div class="file">portfolio-site/</div>
                <div class="file">ml-experiments/</div>
                <div class="file">api-tools/</div>
                <div class="file">README.md</div>

                <pre>
// Current projects:
- Building a neural network from scratch
- Automated trading bot (work in progress)
- Various web scraping utilities
- Machine learning experiments
- This portfolio site

// Tech stack:
Python, JavaScript, React, Node.js, PostgreSQL, Docker
                </pre>
            </div>

            <!-- About -->
            <div id="about" class="content">
                <div class="back" onclick="goBack()">← /home/jake</div>
                <pre>
Jake Davis

Software developer and neuroscience student.
Interested in machine learning, web development, automation, and the human brain.

Currently working on various personal projects and learning new technologies.
Always looking for interesting problems to solve.

Location: Earth
Status: Online
                </pre>
            </div>

            <!-- Contact -->
            <div id="contact" class="content">
                <div class="back" onclick="goBack()">← /home/jake</div>
                <div class="file">email.txt</div>
                <div class="file">github</div>
                <div class="file">linkedin</div>
                <div class="file">twitter</div>

                <pre>
// Get in touch:

email: jake@bryt.works
github: github.com/jakedev
linkedin:
instagram: @jjakedavis

// Or just send a message:
echo "hello" | mail jake@bryt.works
                </pre>
            </div>

            <!-- Resume -->
            <div id="resume" class="content">
                <div class="back" onclick="goBack()">← /home/jake</div>
                <pre>
JAKE DAVIS
Software Developer

EXPERIENCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Software Developer Intern | Tech Corp | 2024
- Built web applications using React and Node.js
- Worked with REST APIs and database design
- Collaborated with team of 5 developers

EDUCATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Neuroscience | Brigham Young University | 2027 (Expected)
Relevant Coursework: Neurobiology, Cognitive Science, Statistics

SKILLS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Languages: Python, JavaScript, Java, C++, Spanish
Frontend: React, HTML/CSS, TypeScript
Backend: Node.js, Express, PostgreSQL
Tools: Git, Docker, AWS, Linux
                </pre>
            </div>

            <!-- Misc/Thoughts -->
            <div id="misc" class="content">
                <div class="back" onclick="goBack()">← /</div>
                <pre>
[2024-01-15 14:32] Starting new ML project
[2024-01-12 09:15] Coffee intake: excessive
[2024-01-10 23:47] Fixed the bug. It was a semicolon.
[2024-01-08 16:20] Why do I always code better at night?
[2024-01-05 11:30] New year, new repository structure
[2024-01-03 08:45] Reading papers on transformer architectures
[2024-01-01 00:01] Hello 2024
                </pre>
            </div>

            <!-- Hidden -->
            <div id="hidden" class="content">
                <div class="back" onclick="goBack()">← /</div>
                <pre>
You found the secret file!

    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    ░░░█████░░██████░░░███░░░███████░░░░░░░
    ░░░█░░░█░░█░░░░█░░█░░░█░░░░░█░░░░░░░░░░
    ░░░█░░░█░░█░░░░█░░█░░░█░░░░░█░░░░░░░░░░
    ░░░█████░░██████░░░███░░░░░░█░░░░░░░░░░
    ░░░█░░░█░░█░░░░█░░░░░█░░░░░░█░░░░░░░░░░
    ░░░█░░░█░░█░░░░█░░░░░█░░░░░░█░░░░░░░░░░
    ░░░█████░░█░░░░█░░████░░░░░░█░░░░░░░░░░
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Sometimes the best things are hidden in plain sight.
This path leads to more questions than answers.
But isn't that what makes it interesting?

// Congratulations on finding this
// Keep exploring, keep questioning
                </pre>
            </div>
        </div>

        <div class="graph-container">
            <canvas id="canvas"></canvas>
            <div class="graph-info">Drag nodes • Scroll to zoom • Click to navigate</div>
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        let currentPage = null;

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Graph data representing portfolio sections
        const graphData = {
            nodes: [
                { id: 'home', label: 'home', size: 14, group: 1 },
                { id: 'about', label: 'about', size: 10, group: 2 },
                { id: 'projects', label: 'projects', size: 12, group: 3 },
                { id: 'resume', label: 'resume', size: 11, group: 3 },
                { id: 'contact', label: 'contact', size: 9, group: 2 },
                { id: 'misc', label: 'thoughts', size: 10, group: 4 },
                { id: 'hidden', label: '???', size: 8, group: 5 }
            ],
            links: [
                { source: 'home', target: 'about' },
                { source: 'home', target: 'projects' },
                { source: 'home', target: 'resume' },
                { source: 'home', target: 'contact' },
                { source: 'about', target: 'resume' },
                { source: 'projects', target: 'resume' },
                { source: 'contact', target: 'about' },
                { source: 'misc', target: 'home' },
                { source: 'misc', target: 'projects' },
                { source: 'hidden', target: 'misc' }
            ]
        };

        const groupColors = {
            1: '#ffffff',
            2: '#cccccc',
            3: '#aaaaaa',
            4: '#888888',
            5: '#666666'
        };

        let settings = {
            repulsion: 120,
            linkDistance: 100,
            damping: 0.85,
            centeringForce: 0.015
        };

        // Initialize physics
        graphData.nodes.forEach(node => {
            node.x = Math.random() * canvas.width;
            node.y = Math.random() * canvas.height;
            node.vx = 0;
            node.vy = 0;
            node.fx = null;
            node.fy = null;
        });

        const neighbors = new Map();
        graphData.nodes.forEach(node => neighbors.set(node.id, new Set()));
        graphData.links.forEach(link => {
            neighbors.get(link.source).add(link.target);
            neighbors.get(link.target).add(link.source);
        });

        // Interaction state
        let dragNode = null;
        let hoveredNode = null;
        let isDragging = false;
        let panOffset = { x: 0, y: 0 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let zoom = 1;

        function getNodeAt(x, y) {
            const adjustedX = (x - panOffset.x) / zoom;
            const adjustedY = (y - panOffset.y) / zoom;

            return graphData.nodes.find(node => {
                const dx = adjustedX - node.x;
                const dy = adjustedY - node.y;
                return Math.sqrt(dx * dx + dy * dy) < node.size * 2;
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            dragNode = getNodeAt(x, y);
            if (dragNode) {
                dragNode.fx = dragNode.x;
                dragNode.fy = dragNode.y;
                isDragging = true;
            } else {
                isPanning = true;
                panStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isDragging && dragNode) {
                dragNode.fx = (x - panOffset.x) / zoom;
                dragNode.fy = (y - panOffset.y) / zoom;
            } else if (isPanning) {
                panOffset.x = e.clientX - panStart.x;
                panOffset.y = e.clientY - panStart.y;
            } else {
                const newHoveredNode = getNodeAt(x, y);
                if (newHoveredNode !== hoveredNode) {
                    hoveredNode = newHoveredNode;
                    if (hoveredNode) {
                        tooltip.textContent = hoveredNode.label;
                        tooltip.classList.add('visible');
                    } else {
                        tooltip.classList.remove('visible');
                    }
                }
                if (hoveredNode) {
                    tooltip.style.left = e.clientX + 15 + 'px';
                    tooltip.style.top = e.clientY + 15 + 'px';
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (dragNode && !isDragging) {
                // This was a click, not a drag
                navigate(dragNode.id);
            }

            if (dragNode) {
                dragNode.fx = null;
                dragNode.fy = null;
            }
            dragNode = null;
            isDragging = false;
            isPanning = false;
        });

        canvas.addEventListener('mouseleave', () => {
            if (dragNode) {
                dragNode.fx = null;
                dragNode.fy = null;
            }
            dragNode = null;
            isDragging = false;
            isPanning = false;
            hoveredNode = null;
            tooltip.classList.remove('visible');
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.3, Math.min(3, zoom * zoomFactor));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            panOffset.x = mouseX - (mouseX - panOffset.x) * (newZoom / zoom);
            panOffset.y = mouseY - (mouseY - panOffset.y) * (newZoom / zoom);

            zoom = newZoom;
        });

        // Physics simulation
        function simulate() {
            const alpha = 0.3;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            graphData.nodes.forEach(node => {
                if (node.fx !== null) {
                    node.x = node.fx;
                    node.y = node.fy;
                    node.vx = 0;
                    node.vy = 0;
                    return;
                }

                let fx = 0, fy = 0;

                // Repulsion
                graphData.nodes.forEach(other => {
                    if (node === other) return;
                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq) || 1;

                    const nodeMass = node.size / 8;
                    const otherMass = other.size / 8;
                    const force = (settings.repulsion * nodeMass * otherMass) / distSq;
                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;
                });

                // Attraction along links
                graphData.links.forEach(link => {
                    let source, target;
                    if (link.source === node.id) {
                        source = node;
                        target = graphData.nodes.find(n => n.id === link.target);
                    } else if (link.target === node.id) {
                        source = node;
                        target = graphData.nodes.find(n => n.id === link.source);
                    }

                    if (source && target) {
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = (dist - settings.linkDistance) / dist;
                        fx += dx * force * 0.1;
                        fy += dy * force * 0.1;
                    }
                });

                // Centering force
                fx += (centerX - node.x) * settings.centeringForce;
                fy += (centerY - node.y) * settings.centeringForce;

                // Update velocity and position
                node.vx = (node.vx + fx * alpha) * settings.damping;
                node.vy = (node.vy + fy * alpha) * settings.damping;
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        // Render
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(panOffset.x, panOffset.y);
            ctx.scale(zoom, zoom);

            // Draw links
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1 / zoom;
            graphData.links.forEach(link => {
                const source = graphData.nodes.find(n => n.id === link.source);
                const target = graphData.nodes.find(n => n.id === link.target);

                if (source && target) {
                    const isConnected = hoveredNode && (
                        source === hoveredNode || target === hoveredNode
                    );
                    ctx.globalAlpha = isConnected ? 0.4 : 0.1;
                    ctx.beginPath();
                    ctx.moveTo(source.x, source.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                }
            });
            ctx.globalAlpha = 1;

            // Draw nodes
            graphData.nodes.forEach(node => {
                const isHovered = node === hoveredNode;
                const isActive = node.id === currentPage;
                const isConnected = hoveredNode && neighbors.get(hoveredNode.id)?.has(node.id);

                ctx.beginPath();
                ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
                ctx.fillStyle = groupColors[node.group] || '#888';
                ctx.globalAlpha = isHovered || isConnected || !hoveredNode ? 1 : 0.3;
                ctx.fill();

                if (isActive) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 / zoom;
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;

                // Label
                if (isHovered || isActive || node.size > 12) {
                    ctx.font = `${11 / zoom}px JetBrains Mono, monospace`;
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.fillText(node.label, node.x, node.y + node.size + 18 / zoom);
                }
            });

            ctx.restore();
        }

        // Animation loop
        function animate() {
            simulate();
            render();
            requestAnimationFrame(animate);
        }
        animate();

        // Navigation functions
        function navigate(page) {
            document.getElementById('main').style.display = 'none';
            document.querySelectorAll('.content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(page).classList.add('active');
            currentPage = page;
        }

        function goBack() {
            document.getElementById('main').style.display = 'block';
            document.querySelectorAll('.content').forEach(content => {
                content.classList.remove('active');
            });
            currentPage = 'home';
        }

        // Initialize
        currentPage = 'home';
    </script>
</body>
</html>
